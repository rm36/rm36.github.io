<html>
<script src='https://d3js.org/d3.v5.min.js'></script>
<script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
<style> circle {stroke: black;} </style>
<body onload='init()'>
<div id="stream_graph"></div>
<div id="stream_graph_fraction"></div>
<script>

function getSvgWithMargins(id, width, height, margin) {
    return d3.select(id)
        .append("svg")
            .attr("width", width + 2*margin)
            .attr("height", height + 2*margin)
        .append("g")
            .attr("transform", "translate(" + margin + "," + margin + ")");
}

function formatXAxis(svg, height, x, ticks) {
    svg.append("g")
        .attr("transform", "translate(0," + (height*0.82) + ")")
        .call(d3.axisBottom(x)
            .tickSize(-height*0.82)
            .tickValues(ticks)
            .tickFormat(d3.format(".4")))
        .select(".domain").remove();
    svg.selectAll(".tick line").attr("stroke", "#bbbbbb");
}

function formatYAxisPercent(svg, width, y) {
    let percents = []
    for (let i = -0.5; i <= 0.5; i += 0.1) {
        percents.push(i);
    }
    let a = svg.append("g")
        .call(d3.axisLeft(y)
            .tickSize(-width)
            .tickValues(percents)
            .tickFormat((d) => "" + Math.round(100*(0.5-d)) + "%"))
        .select(".domain").remove();
    svg.selectAll(".tick line").attr("stroke", "#bbbbbb");
}

function getFraction (data) {
    let fraction = [];
    for (let i = 0; i < data.length; i++) {
        let sum = 0;
        for (let key in data[i]) {
            if (key != 'Year') {
                sum += parseInt(data[i][key]);
            }
        }

        fraction.push({});
        for (let key in data[i]) {
            if (key == 'Year') {
                fraction[i][key] = parseInt(data[i][key]);
            } else {    
                fraction[i][key] = parseInt(data[i][key]) / sum;
            }
        }
    }
    return fraction;
}

function generateArea(x, y) {
    return d3.area()
    .x(function(d) { return x(d.data.Year); })
    .y0(function(d) { return y(d[0]); })
    .y1(function(d) { return y(d[1]); });
}

function getBounds(element) {
    return element.node().getBoundingClientRect();
}

async function init() {
    let margin = 30,
        width = 500 - 2*margin;
        height = 400 - 2*margin;

    let svg = getSvgWithMargins("#stream_graph", width, height, margin);
    let svgFraction = getSvgWithMargins("#stream_graph_fraction", width, height, margin);

    data = await d3.csv("https://rm36.github.io/degrees_conferred.csv");
    let fraction = getFraction(data);

    // Get the header of the csv files
    let keys = data.columns.slice(1);

    let xScale = d3.scaleLinear()
        .domain(d3.extent(data, function(d) { return d.Year; })).range([ 0, width ]);

    let years = [1971, 1980, 1990, 2000, 2010, 2020];
    formatXAxis(svg, height, xScale, years);
    formatXAxis(svgFraction, height, xScale, years);

    let yScale = d3.scaleLinear().domain([-1000000, 1000000]).range([0, height * 0.8]);
    let yFractionScale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, height * 0.8]);

    formatYAxisPercent(svgFraction, width, yFractionScale);

    let color = d3.scaleOrdinal().domain(keys).range(d3.schemeCategory10);

    let stackedData = d3.stack().offset(d3.stackOffsetSilhouette).keys(keys)(data);
    let stackedDataFraction = d3.stack().offset(d3.stackOffsetSilhouette).keys(keys)(fraction);

    let majorText = svg
        .append("text")
        .attr("x", 0)
        .attr("y", 0)
        .style("opacity", 0)
        .style("font-size", 17);

    const annotations = [
      {
        note: {
          label: "Label",
          title: "Title"
        },
        x: 50,
        y: 50,
        dy: 50,
        dx: 50,
        connector: { end: "dot" },
        type: d3.annotationCalloutElbow,
      }
    ];

    function findNearest(x, y, data, major) {
        exactYear = xScale.invert(x - margin);
        let closestDist = 20;
        let closestYear = 2020;
        let closestEnrolled = 0;
        let accumEnrolled = 0;
        for (let i = 0; i < data.length; i++) {
            year = data[i].data.Year;
            let dist = Math.abs(exactYear - year);
            if (dist < closestDist) {
                closestDist = dist;
                closestYear = year;
                closestEnrolled = data[i].data[major];
                accumEnrolled = data[i];
            }
        }
        averageAccumValue = (accumEnrolled[0]+accumEnrolled[1])/2;
        return {'year': closestYear,
                'x': xScale(closestYear) + margin,
                'y': yScale(averageAccumValue),
                'yRelative': yFractionScale(averageAccumValue),
                'enrolled': closestEnrolled};
    }

    function formatMajorAndYear(major, year) {
        let majorStr = major;
        let maxLength = 5;
        if (major.length > maxLength + 3) {
            majorStr = major.substring(0, maxLength) + "...";
        }
        return majorStr + " - " + year;
    }

    function formatEnrolled(enrolled) {
        return d3.format(",.8")(enrolled);
    }
    function formatEnrolledPercent(enrolled) {
        return d3.format("00.2%")(enrolled);
    }

    function getCenteredDx(x, left, width) {
        return (x - left < width/2) ? 50 : -50;
    }
    function getCenteredDy(y, top, height) {
        return (y - top < height/2) ? 50 : -50;
    }

    function updateTooltipDegrees(tooltip, x, y, major, data) {
        let nearest = findNearest(x, y, data, major);
        bounds = getBounds(svg);
        tooltip.dx = getCenteredDx(x, bounds.left, bounds.width);
        tooltip.dy = getCenteredDy(y, bounds.top, bounds.height);
        tooltip.x = nearest.x - margin;
        tooltip.y = nearest.y;
        tooltip.note.title = formatMajorAndYear(major, nearest.year);
        tooltip.note.label = "Enrolled: " + formatEnrolled(nearest.enrolled) + "\n";
    }
    function updateTooltipRelative(tooltip, x, y, major, data) {
        let nearest = findNearest(x, y, data, major);
        bounds = getBounds(svgFraction);
        tooltip.dx = getCenteredDx(x, bounds.left, bounds.width);
        tooltip.dy = getCenteredDy(y, bounds.top, bounds.height);
        tooltip.x = nearest.x - margin;
        tooltip.y = nearest.yRelative;
        tooltip.note.title = formatMajorAndYear(major, nearest.year);
        tooltip.note.label = "Enrolled: " + formatEnrolledPercent(nearest.enrolled);
    }

    // Reactive mouse callbacks
    let mouseover = function(d) {
        majorText.style("opacity", 1);
        d3.selectAll(".degreeArea").style("opacity", 0.25);
        d3.selectAll(".degreeAreaRelative").style("opacity", 0.25);

        // Select the corresponding node to the index
        d3.select(degreeAreas.nodes()[d.index]).style("stroke", "black").style("opacity", 1);
        d3.select(fractionAreas.nodes()[d.index]).style("stroke", "black").style("opacity", 1);
    }
    let mousemoveDegrees = function(d,i) {
        major = keys[i];
        majorText.text(major);
        updateTooltipDegrees(annotations[0], d3.event.x, d3.event.y, major, d);
        makeAnnotations.annotations(annotations);
        makeAnnotations.update();
    }
    let mousemoveRelative = function(d,i) {
        major = keys[i];
        majorText.text(major);
        updateTooltipRelative(annotations[0], d3.event.x, d3.event.y, major, d);
        makeAnnotationsFraction.annotations(annotations);
        makeAnnotationsFraction.update();
    }
    let mouseleave = function(d) {
        majorText.style("opacity", 0);
        d3.selectAll(".degreeArea").style("opacity", 1).style("stroke", "none");
        d3.selectAll(".degreeAreaRelative").style("opacity", 1).style("stroke", "none");
        d3.selectAll('.annotations').remove();
    }

    let area = generateArea(xScale, yScale);
    let areaFraction = generateArea(xScale, yFractionScale);

    let degreeAreas = svg.selectAll("layerData")
        .data(stackedData)
        .enter()
        .append("path")
            .attr("class", "degreeArea")
        .style("fill", function(d) { return color(d.key); })
            .attr("d", area);

    let fractionAreas = svgFraction.selectAll("layerDataRelative")
        .data(stackedDataFraction)
        .enter()
        .append("path")
            .attr("class", "degreeAreaRelative")
        .style("fill", function(d) { return color(d.key); })
            .attr("d", areaFraction);

    // Add annotation to the chart on top of areas
    makeAnnotations = d3.annotation().annotations(annotations);
    makeAnnotationsFraction = d3.annotation().annotations(annotations);
    svg.append("g").call(makeAnnotations);
    svgFraction.append("g").call(makeAnnotationsFraction);
    d3.selectAll('.annotations').remove();

    // Add mouse over events on top of the annotation
    svg.selectAll("layerDataHover")
        .data(stackedData)
        .enter()
        .append("path")
            .attr("class", "degreeAreaHover")
        .style("fill", function(d) { return color(d.key); })
            .attr("d", area)
        .style("opacity", 0)
        .on("mouseover", mouseover)
        .on("mousemove", mousemoveDegrees)
        .on("mouseleave", mouseleave);

    svgFraction.selectAll("layerDataRelativeHover")
        .data(stackedDataFraction)
        .enter()
        .append("path")
            .attr("class", "degreeAreaRelativeHover")
        .style("fill", function(d) { return color(d.key); })
            .attr("d", areaFraction)
        .style("opacity", 0)
        .on("mouseover", mouseover)
        .on("mousemove", mousemoveRelative)
        .on("mouseleave", mouseleave);

    // Year labels
    svg.append("text")
        .attr("text-anchor", "end")
        .attr("x", width/2)
        .attr("y", height-30 )
        .text("Year");
    svgFraction.append("text")
        .attr("text-anchor", "end")
        .attr("x", width/2)
        .attr("y", height-30 )
        .text("Year");
}

</script>
</body>
</html>